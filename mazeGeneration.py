import random
import threading

from constants import *
from classes import *

# This function removes the borders of a node
# The direction specifies which border needs to be removed
def removeBorders(maze, i, j, direction):

    if direction == 'up':
        maze[j][i].up = False
        maze[j - 1][i].down = False

    if direction == 'right':
        maze[j][i].right = False
        maze[j][i + 1].left = False

    if direction == 'down':
        maze[j][i].down = False
        maze[j + 1][i].up = False

    if direction == 'left':
        maze[j][i].left = False
        maze[j][i - 1].right = False

# Function that generates a maze
# The start is at the top left and end is the bottom right
def generateMaze(maze):

    for i in range(NUMBER_OF_BLOCKS):
        for j in range(NUMBER_OF_BLOCKS):
            maze[j][i] = Node()

    # Instantiate the start and end of the maze
    # These are the top left and bottom right corners
    maze[0][0].state = "green"
    maze[NUMBER_OF_BLOCKS - 1][NUMBER_OF_BLOCKS - 1].state = "red"

    i = random.randrange(0, NUMBER_OF_BLOCKS)
    j = random.randrange(0, NUMBER_OF_BLOCKS)

    DFSgeneration(maze[i][j], i, j, maze)

# Maze generation using DFS
def DFSgeneration(node, i, j, maze):

    if node.state not in ['green', 'red']:
        node.state = 'orange'

    threading.Event().wait(REFRESH_RATE / 1000)

    if node.state == 'orange':
        node.state = 'white'

    # Mark the current node as generated
    node.generated = True

    # This is a list that contains the neighboring nodes that have not been generated by DFS
    # It is a list of actions that contain the node and the direction with respect to the original node
    neighbors = []

    if i - 1 >= 0 and not maze[j][i - 1].generated:
        neighbors.append(Action(maze[j][i - 1], 'left', i - 1, j))
    
    if i + 1 < NUMBER_OF_BLOCKS and not maze[j][i + 1].generated:
        neighbors.append(Action(maze[j][i + 1], 'right', i + 1, j))
    
    if j + 1 < NUMBER_OF_BLOCKS and not maze[j + 1][i].generated:
        neighbors.append(Action(maze[j + 1][i], 'down', i, j + 1))
    
    if j - 1 >= 0 and not maze[j - 1][i].generated:
        neighbors.append(Action(maze[j - 1][i], 'up', i, j - 1))

    while neighbors:

        action = neighbors.pop(random.randrange(0, len(neighbors)))

        # Due to the recursive nature of the program, the status of a node in the stack can change
        if action.node.generated == True:
            continue

        removeBorders(maze, i, j, action.direction)

        DFSgeneration(action.node, action.newX, action.newY, maze)